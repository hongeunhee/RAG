# -*- coding: utf-8 -*-
"""
Created on Fri Jun  7 13:57:59 2024

@author: 202202871
"""

import streamlit as st
import os
import pandas as pd
import google.generativeai as genai
from IPython.display import Markdown, display
import textwrap
from ipaddress import ip_address


# Start Streamlit app
st.set_page_config(page_title="Vulnerability Scanner: Analyze your weblog data", page_icon="ğŸ¦œ")
st.title("ğŸ¦œ Vulnerability Scanner: Analyze your web log data")

folder_path = st.sidebar.text_input(label="Local file path", type="default")
gemini_api_key = st.sidebar.text_input(label="Gemini API Key", type="password",)

# Check user inputs
if not folder_path:
    st.info("Please enter the folder path for the local weblog data in the sidebar.")
    st.stop()

if not gemini_api_key:
    st.info("Please add your Gemini API key to the sidebar to continue.")
    st.stop()
    
# Verify that the path entered is valid
if folder_path:
    if os.path.isdir(folder_path):
        st.write(f"Entered path: {folder_path}")
        st.write("Folder Content:")
        # Output a list of files and directories in a folder
        for item in os.listdir(folder_path):
            st.write(item)
    else:
        st.error("Please enter a valid folder path.")
else:
    st.write("Please enter your folder path.")

def merge_text_files_to_dataframe(folder_path):
    # í´ë” ë‚´ ëª¨ë“  í…ìŠ¤íŠ¸ íŒŒì¼ ìˆ˜ì§‘
    file_paths = [os.path.join(folder_path, file) for file in os.listdir(folder_path) if file.endswith('.txt')]
    
    # ëª¨ë“  í…ìŠ¤íŠ¸ íŒŒì¼ì„ í•˜ë‚˜ì˜ ë°ì´í„°í”„ë ˆì„ìœ¼ë¡œ ë³‘í•©
    parsed_data = []
    columns = ['IP', 'NV1', 'NV2', 'DateTime', 'NV3', 'Request1', 'Request2', 'Protocol', 'ResponseCode', 'Size']

    for file_path in file_paths:
        with open(file_path, 'r') as file:
            for line in file:
                parts = line.split(' ')
                parsed_row = dict(zip(columns, parts))
                parsed_data.append(parsed_row)

    # DataFrameìœ¼ë¡œ ë³€í™˜
    df = pd.DataFrame(parsed_data)
    # 'DateTime' ì—´ì„ ê¸°ì¤€ìœ¼ë¡œ ë°ì´í„°í”„ë ˆì„ì„ ì •ë ¬
    df['DateTime'] = df['DateTime'].apply(lambda x: x.replace ('[',''))
    df['DateTime'] = pd.to_datetime(df['DateTime'], format="%d/%b/%Y:%H:%M:%S")
    df.sort_values(by='DateTime', inplace=True)
    return df
 
def filter_logs_within_1_minute(sorted_data):
    
    filtered_logs = []
    
    # ë°ì´í„°ë¥¼ ë°˜ë³µí•˜ë©´ì„œ í•„í„°ë§
    for i in range(len(sorted_data)):
        current_entry = sorted_data[i]
        current_datetime = current_entry['DateTime']
        current_ip = current_entry['IP']
        current_response_code = current_entry['ResponseCode']
        
        # í˜„ì¬ ë¡œê·¸ê°€ '404' ì‘ë‹µ ì½”ë“œë¥¼ ê°€ì§€ê³  ìˆëŠ”ì§€ í™•ì¸
        if current_response_code in ['404']:
            # ë‹¤ìŒ ë¡œê·¸ë¶€í„° 1ì´ˆ ì´ë‚´ì˜ ë¡œê·¸ë¥¼ í™•ì¸
            for j in range(i+1, len(sorted_data)):
                next_entry = sorted_data[j]
                next_datetime = next_entry['DateTime']
                next_ip = next_entry['IP']
                next_response_code = next_entry['ResponseCode']
                
                # 1ì´ˆ ì´ë‚´ì˜ ë¡œê·¸ì´ê³  ë™ì¼í•œ IPì— ëŒ€í•´ '404'ì™€ '200' ì‘ë‹µ ì½”ë“œë¥¼ ê°€ì§€ê³  ìˆëŠ” ê²½ìš° í•„í„°ë§
                if (next_datetime - current_datetime).total_seconds() <= 1 and next_ip == current_ip and next_response_code in ['404', '200']:
                    filtered_logs.append(current_entry)
                    break
    
    return filtered_logs

def attacked_web_log(filtered_logs):
    # 1ì´ˆ ì´ë‚´ 404 í˜¹ì€ 200ì—ëŸ¬ 1000ê°œ ì´ˆê³¼ IP ë¦¬ìŠ¤íŠ¸ ì¶”ì¶œ   
    filtered_logs = pd.DataFrame(filtered_logs).sort_values(by='IP')
    ip_counts = pd.DataFrame(filtered_logs['IP'].value_counts())
    ip_counts.columns = ['count']
    atk_ip = ip_counts[ip_counts['count'] >= 1000]
    atk_ip_lst = atk_ip.index.to_list()
    # í•´ë‹¹ IPì— ëŒ€í•œ ì›¹ë¡œê·¸ ë°ì´í„°
    atk_info = dataframe[dataframe['IP'].isin(atk_ip_lst)]
    # ì¤‘ìš” íŒ¨í„´ì„ ê°€ì§„ ì›¹ë¡œê·¸ë§Œ í•„í„°ë§ 
    ptn_plt = atk_info[atk_info['Request2'].str.contains("' OR '1'='1|%|passwd|cgi-bin")]
    # ê³µê²©ì— ì„±ê³µí•œ ì›¹ë¡œê·¸ í•„í„°ë§
    ptn_plt.loc[:, 'ResponseCode'] = ptn_plt.loc[:, 'ResponseCode'].astype(int)
    atk_scs = ptn_plt[ptn_plt['ResponseCode'].apply(lambda x: eval(f"x {'==200'}"))]
    scan_frt_day = atk_scs['DateTime'].iloc[0]
    atk_scs_count = len(atk_scs)
    
    # ìŠ¤ìº” ì´í›„ ë°ì´í„° ê°’ì—ì„œ ì‹ ê·œ IPì™€ ìŠ¤ìº” ê³¼ì •ì—ì„œ ì´ìƒ IPì— ëŒ€í•œ ë°ì´í„°ë§Œ í•„í„°ë§
    scan_lst_day = atk_scs['DateTime'].iloc[-1]
    scan_b4_ip = dataframe[dataframe['DateTime'] <= scan_lst_day]['IP'].unique().tolist()
    for i in atk_ip_lst:
        scan_b4_ip.remove(i)
    afs = dataframe[dataframe['DateTime'] > scan_lst_day]
    new_ip_info = afs.loc[~(afs['IP'].isin(scan_b4_ip))]

    # ResponseCode 200ì¸ ì†ŒìŠ¤ì½”ë“œ í•„í„°ë§
    new_ip_info.loc[:, 'ResponseCode'] = new_ip_info.loc[:, 'ResponseCode'].astype(int)
    new_ip_info_200 = new_ip_info[new_ip_info['ResponseCode'].apply(lambda x: eval(f"x {'==200'}"))]
   
    # Sizeê°€ í‰ê· ì˜ 10ë°° ì´ìƒì¸ ì†ŒìŠ¤ì½”ë“œ í•„í„°ë§
    new_ip_info_200.loc[:, 'Size'] = new_ip_info_200.loc[:, 'Size'].astype(int)
    size_lst = new_ip_info_200['Size'].tolist()
    size_avg = sum(size_lst)/len(size_lst)
    abnormal = new_ip_info_200[new_ip_info_200['Size'] >= size_avg*10]

    atk_ip_count = len(atk_ip_lst)
    st.write(f"There are a total of {atk_ip_count} IPs used to scan vulnerabilities, and the IPs are as follows: {atk_ip_lst}")
    st.write(f"ì·¨ì•½ì  ìŠ¤ìº” ì‹œì‘ ì‹œì ì€ {scan_frt_day}ì´ê³  ì¢…ë£Œ ì‹œì ì€ {scan_lst_day}ì…ë‹ˆë‹¤. ì´ {atk_scs_count}ë²ˆì˜ ì·¨ì•½ì ì„ ìŠ¤ìº”í–ˆìŠµë‹ˆë‹¤.")
    
    return atk_scs, abnormal
    
def get_public_ips(ip_list):
    public_ips = []
    
    for ip in ip_list:
        if not is_private_ip(ip):
            public_ips.append(ip)
    
    return public_ips
 
# ì‚¬ì„¤ IP ì£¼ì†Œ ì—¬ë¶€ë¥¼ í™•ì¸í•˜ëŠ” í•¨ìˆ˜
def is_private_ip(ip):
    private_ip_ranges = [
("10.0.0.0", "10.255.255.255"),
("172.16.0.0", "172.31.255.255"),
("192.168.0.0", "192.168.255.255")
    ]
    
    for start, end in private_ip_ranges:
        if ip_address(start) <= ip_address(ip) <= ip_address(end):
            return True
    return False
 
#Create a helper function that will convert the markdwon into nicely formatted text
def to_markdown(text):
  return Markdown(textwrap.indent(text, '>', predicate=lambda _: True))
 
if __name__=="__main__":
    
    dataframe = merge_text_files_to_dataframe(folder_path)
    dic_df = dataframe.to_dict(orient='records')
    
    # ì´ìƒ íƒì§€í•œ ì›¹ë¡œê·¸ ì¶œë ¥
    filtered_logs = filter_logs_within_1_minute(dic_df)
    
    ### ë¶„ì„ ê²°ê³¼ ì¶œë ¥ ë‹¨ê³„ ###
    # gemini-agent êµ¬ì„±
    #api_key = 'AIzaSyAij_2eLy-nzQVRDouKKur-1TfObHYi3E8' 
    genai.configure(api_key = gemini_api_key) #transport='grpc_asyncio' The user can pass a string to choose 'rest' or 'grpc' or 'grpc_asyncio'
    model = genai.GenerativeModel("models/gemini-1.5-pro-latest")
    ### ê¸°ë³¸ ì¶œë ¥ ###
    atk_scs, abnormal = attacked_web_log(filtered_logs)
    ### ì·¨ì•½ì  ìŠ¤ìº” ê¸°ê°„ ë™ì•ˆì˜ í˜ì´ë¡œë“œ ë¶„ì„ ê²°ê³¼ ì¶œë ¥ ###
    st.write("ì·¨ì•½ì  ìŠ¤ìº” ë™ì•ˆì˜ í˜ì´ë¡œë“œ ë¶„ì„ ê²°ê³¼ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.")
    lst = atk_scs['Request2'].tolist()
    response = model.generate_content(f"{lst}: í•´ë‹¹ í˜ì´ë¡œë“œë“¤ì„ ë¶„ì„í•´ì¤˜")
    st.write(response['text'])
    ### ì·¨ì•½ì  ìŠ¤ìº” ì´í›„ í˜ì´ë¡œë“œ ë¶„ì„ ê²°ê³¼ ì¶œë ¥ ###
    st.write("ë‹¤ìŒì€ ì·¨ì•½ì  ìŠ¤ìº” ì´í›„ í˜ì´ë¡œë“œ ë¶„ì„ ê²°ê³¼ì…ë‹ˆë‹¤.")
    pay_lst = abnormal['Request2'].tolist()
    response = model.generate_content(f"{pay_lst}: í˜ì´ë¡œë“œë¥¼ ë¶„ì„í•´ ì¤˜. íŠ¹ë³„í•œ ì ì´ ì—†ìœ¼ë©´ ì—†ë‹¤ê³  ì•Œë ¤ì¤˜")
    st.write(response['text'])
    st.write("ë‹¤ìŒì€ ì·¨ì•½ì  ìŠ¤ìº” ì´í›„ API ë³´ì•ˆ ì·¨ì•½ì ì— ëŒ€í•œ ë¶„ì„ ê²°ê³¼ì…ë‹ˆë‹¤.")
    response = model.generate_content(f"{pay_lst}: OWASP API ë³´ì•ˆ TOP10ì— í•´ë‹¹í•˜ëŠ” ì·¨ì•½ì ì´ ìˆìœ¼ë©´ ì•Œë ¤ì¤˜. íŠ¹ë³„í•œ ì ì´ ì—†ìœ¼ë©´ ì—†ë‹¤ê³  ì•Œë ¤ì¤˜")
    st.write(response['text'])
